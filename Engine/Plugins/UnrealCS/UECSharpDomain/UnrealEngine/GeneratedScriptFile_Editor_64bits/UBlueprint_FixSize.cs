#if WITH_EDITOR
#if PLATFORM_64BITS
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace UnrealEngine
{
	/// <summary>
	/// Blueprints are special assets that provide an intuitive, node-based interface that can be used to create new types of Actors
	/// and script level events; giving designers and gameplay programmers the tools to quickly create and iterate gameplay from
	/// within Unreal Editor without ever needing to write a line of code.
	/// </summary>
	public partial class UBlueprint
	{
		static readonly int bRecompileOnLoad__Offset;
		/// <summary>Whether or not this blueprint should recompile itself on load</summary>
		public bool bRecompileOnLoad
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bRecompileOnLoad__Offset, 1, 0, 1, 1);}
			
		}
		
		static readonly int ParentClass__Offset;
		/// <summary>
		/// Pointer to the parent class that the generated class should derive from. This *can* be null under rare circumstances,
		/// one such case can be created by creating a blueprint (A) based on another blueprint (B), shutting down the editor, and
		/// deleting the parent blueprint.
		/// </summary>
		public TSubclassOf<UObject>  ParentClass
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + ParentClass__Offset); return v; }
			
		}
		
		static readonly int PRIVATE_InnermostPreviousCDO__Offset;
		public UObject PRIVATE_InnermostPreviousCDO
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + PRIVATE_InnermostPreviousCDO__Offset); if (v == IntPtr.Zero)return null; UObject retValue = new UObject(); retValue._this = v; return retValue; }
			
		}
		
		static readonly int bHasBeenRegenerated__Offset;
		/// <summary>When the class generated by this blueprint is loaded, it will be recompiled the first time.  After that initial recompile, subsequent loads will skip the regeneration step</summary>
		public bool bHasBeenRegenerated
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bHasBeenRegenerated__Offset, 1, 0, 1, 1);}
			
		}
		
		static readonly int bIsRegeneratingOnLoad__Offset;
		/// <summary>State flag to indicate whether or not the Blueprint is currently being regenerated on load</summary>
		public bool bIsRegeneratingOnLoad
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bIsRegeneratingOnLoad__Offset, 1, 0, 2, 2);}
			
		}
		
		static readonly int bIsNewlyCreated__Offset;
		/// <summary>Whether or not this blueprint is newly created, and hasn't been opened in an editor yet</summary>
		public bool bIsNewlyCreated
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bIsNewlyCreated__Offset, 1, 0, 4, 4);}
			
		}
		
		static readonly int bForceFullEditor__Offset;
		/// <summary>Whether to force opening the full (non data-only) editor for this blueprint.</summary>
		public bool bForceFullEditor
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bForceFullEditor__Offset, 1, 0, 8, 8);}
			
		}
		
		static readonly int bRunConstructionScriptOnDrag__Offset;
		/// <summary>whether or not you want to continuously rerun the construction script for an actor as you drag it in the editor, or only when the drag operation is complete</summary>
		public bool bRunConstructionScriptOnDrag
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bRunConstructionScriptOnDrag__Offset, 1, 0, 16, 16);}
			set{ CheckIsValid();BoolWrap.Set(value,_this.Get(), bRunConstructionScriptOnDrag__Offset, 1,0,16,16);}
			
		}
		
		static readonly int bGenerateConstClass__Offset;
		/// <summary>Whether or not this blueprint's class is a const class or not.  Should set CLASS_Const in the KismetCompiler.</summary>
		public bool bGenerateConstClass
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bGenerateConstClass__Offset, 1, 0, 32, 32);}
			set{ CheckIsValid();BoolWrap.Set(value,_this.Get(), bGenerateConstClass__Offset, 1,0,32,32);}
			
		}
		
		static readonly int bGenerateAbstractClass__Offset;
		/// <summary>Whether or not this blueprint's class is a abstract class or not.  Should set CLASS_Abstract in the KismetCompiler.</summary>
		public bool bGenerateAbstractClass
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bGenerateAbstractClass__Offset, 1, 0, 64, 64);}
			set{ CheckIsValid();BoolWrap.Set(value,_this.Get(), bGenerateAbstractClass__Offset, 1,0,64,64);}
			
		}
		
		static readonly int BlueprintDescription__Offset;
		/// <summary>shows up in the content browser when the blueprint is hovered</summary>
		public FString BlueprintDescription
		{
			get{ CheckIsValid();return (FString)Marshal.PtrToStructure(_this.Get()+BlueprintDescription__Offset, typeof(FString));}
			set{ CheckIsValid();Marshal.StructureToPtr(value, _this.Get()+BlueprintDescription__Offset, false);}
			
		}
		
		static readonly int BlueprintCategory__Offset;
		/// <summary>The category of the Blueprint, used to organize this Blueprint class when displayed in palette windows</summary>
		public FString BlueprintCategory
		{
			get{ CheckIsValid();return (FString)Marshal.PtrToStructure(_this.Get()+BlueprintCategory__Offset, typeof(FString));}
			set{ CheckIsValid();Marshal.StructureToPtr(value, _this.Get()+BlueprintCategory__Offset, false);}
			
		}
		
		static readonly int HideCategories__Offset;
		/// <summary>Additional HideCategories. These are added to HideCategories from parent.</summary>
		public TStructArray<FString> HideCategories
		{
			get{ CheckIsValid();return new TStructArray<FString>((FScriptArray)Marshal.PtrToStructure(_this.Get()+HideCategories__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+HideCategories__Offset, false);}
			
		}
		
		static readonly int bDisplayCompilePIEWarning__Offset;
		/// <summary>TRUE to show a warning when attempting to start in PIE and there is a compiler error on this Blueprint</summary>
		public bool bDisplayCompilePIEWarning
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bDisplayCompilePIEWarning__Offset, 1, 0, 1, 255);}
			
		}
		
		static readonly int SearchGuid__Offset;
		/// <summary>Guid key for finding searchable data for Blueprint in the DDC</summary>
		public FGuid SearchGuid
		{
			get{ CheckIsValid();return (FGuid)Marshal.PtrToStructure(_this.Get()+SearchGuid__Offset, typeof(FGuid));}
			
		}
		
		static readonly int bDeprecate__Offset;
		/// <summary>Deprecates the Blueprint, marking the generated class with the CLASS_Deprecated flag</summary>
		public bool bDeprecate
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bDeprecate__Offset, 1, 0, 1, 255);}
			set{ CheckIsValid();BoolWrap.Set(value,_this.Get(), bDeprecate__Offset, 1,0,1,255);}
			
		}
		
		static readonly int SimpleConstructionScript__Offset;
		/// <summary>'Simple' construction script - graph of components to instance</summary>
		public USimpleConstructionScript SimpleConstructionScript
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + SimpleConstructionScript__Offset); if (v == IntPtr.Zero)return null; USimpleConstructionScript retValue = new USimpleConstructionScript(); retValue._this = v; return retValue; }
			
		}
		
		static readonly int UbergraphPages__Offset;
		/// <summary>Set of pages that combine into a single uber-graph</summary>
		public TObjectArray<UEdGraph>  UbergraphPages
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+UbergraphPages__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+UbergraphPages__Offset, false);}
			
		}
		
		static readonly int FunctionGraphs__Offset;
		/// <summary>Set of functions implemented for this class graphically</summary>
		public TObjectArray<UEdGraph>  FunctionGraphs
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+FunctionGraphs__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+FunctionGraphs__Offset, false);}
			
		}
		
		static readonly int DelegateSignatureGraphs__Offset;
		/// <summary>Graphs of signatures for delegates</summary>
		public TObjectArray<UEdGraph>  DelegateSignatureGraphs
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+DelegateSignatureGraphs__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+DelegateSignatureGraphs__Offset, false);}
			
		}
		
		static readonly int MacroGraphs__Offset;
		/// <summary>Set of macros implemented for this class</summary>
		public TObjectArray<UEdGraph>  MacroGraphs
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+MacroGraphs__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+MacroGraphs__Offset, false);}
			
		}
		
		static readonly int IntermediateGeneratedGraphs__Offset;
		/// <summary>Set of functions actually compiled for this class</summary>
		public TObjectArray<UEdGraph>  IntermediateGeneratedGraphs
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+IntermediateGeneratedGraphs__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+IntermediateGeneratedGraphs__Offset, false);}
			
		}
		
		static readonly int EventGraphs__Offset;
		/// <summary>Set of functions actually compiled for this class</summary>
		public TObjectArray<UEdGraph>  EventGraphs
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraph>((FScriptArray)Marshal.PtrToStructure(_this.Get()+EventGraphs__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+EventGraphs__Offset, false);}
			
		}
		
		static readonly int bDuplicatingReadOnly__Offset;
		/// <summary>
		/// Flag indicating that a read only duplicate of this blueprint is being created, used to disable logic in ::PostDuplicate,
		/// This flag needs to be copied on duplication (because it's the duplicated object that we're disabling on PostDuplicate),
		/// but we don't *need* to serialize it for permanent objects.
		/// Without setting this flag a blueprint will be marked dirty when it is duplicated and if saved while in this dirty
		/// state you will not be able to open the blueprint. More specifically, UClass::Rename (called by DestroyGeneratedClass)
		/// sets a dirty flag on the package. Once saved the package will fail to open because some unnamed objects are present in
		/// the pacakge.
		/// This flag can be used to avoid the package being marked as dirty in the first place. Ideally PostDuplicateObject
		/// would not rename classes that are still in use by the original object.
		/// </summary>
		public bool bDuplicatingReadOnly
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bDuplicatingReadOnly__Offset, 1, 0, 1, 255);}
			
		}
		
		static readonly int ComponentTemplates__Offset;
		/// <summary>Array of component template objects, used by AddComponent function</summary>
		public TObjectArray<UActorComponent>  ComponentTemplates
		{
					get{ CheckIsValid();return new TObjectArray<UActorComponent>((FScriptArray)Marshal.PtrToStructure(_this.Get()+ComponentTemplates__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+ComponentTemplates__Offset, false);}
			
		}
		
		static readonly int Timelines__Offset;
		/// <summary>Array of templates for timelines that should be created</summary>
		public TObjectArray<UTimelineTemplate>  Timelines
		{
					get{ CheckIsValid();return new TObjectArray<UTimelineTemplate>((FScriptArray)Marshal.PtrToStructure(_this.Get()+Timelines__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+Timelines__Offset, false);}
			
		}
		
		static readonly int InheritableComponentHandler__Offset;
		/// <summary>Stores data to override (in children classes) components (created by SCS) from parent classes</summary>
		public UInheritableComponentHandler InheritableComponentHandler
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + InheritableComponentHandler__Offset); if (v == IntPtr.Zero)return null; UInheritableComponentHandler retValue = new UInheritableComponentHandler(); retValue._this = v; return retValue; }
			
		}
		
		static readonly int BlueprintType__Offset;
		/// <summary>The type of this blueprint</summary>
		public EBlueprintType BlueprintType
		{
			get{ CheckIsValid();return (EBlueprintType)Marshal.PtrToStructure(_this.Get()+BlueprintType__Offset, typeof(EBlueprintType));}
			
		}
		
		static readonly int Status__Offset;
		/// <summary>The current status of this blueprint</summary>
		public EBlueprintStatus Status
		{
			get{ CheckIsValid();return (EBlueprintStatus)Marshal.PtrToStructure(_this.Get()+Status__Offset, typeof(EBlueprintStatus));}
			
		}
		
		static readonly int NewVariables__Offset;
		/// <summary>Array of new variables to be added to generated class</summary>
		public TStructArray<FBPVariableDescription> NewVariables
		{
			get{ CheckIsValid();return new TStructArray<FBPVariableDescription>((FScriptArray)Marshal.PtrToStructure(_this.Get()+NewVariables__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+NewVariables__Offset, false);}
			
		}
		
		static readonly int CategorySorting__Offset;
		/// <summary>Array of user sorted categories</summary>
		public TStructArray<FName> CategorySorting
		{
			get{ CheckIsValid();return new TStructArray<FName>((FScriptArray)Marshal.PtrToStructure(_this.Get()+CategorySorting__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+CategorySorting__Offset, false);}
			
		}
		
		static readonly int ImplementedInterfaces__Offset;
		/// <summary>Array of info about the interfaces we implement in this blueprint</summary>
		public TStructArray<FBPInterfaceDescription> ImplementedInterfaces
		{
			get{ CheckIsValid();return new TStructArray<FBPInterfaceDescription>((FScriptArray)Marshal.PtrToStructure(_this.Get()+ImplementedInterfaces__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+ImplementedInterfaces__Offset, false);}
			
		}
		
		static readonly int BlueprintSystemVersion__Offset;
		/// <summary>The version of the blueprint system that was used to  create this blueprint</summary>
		public int BlueprintSystemVersion
		{
			get{ CheckIsValid();return (int)Marshal.PtrToStructure(_this.Get()+BlueprintSystemVersion__Offset, typeof(int));}
			
		}
		
		static readonly int LastEditedDocuments__Offset;
		/// <summary>Set of documents that were being edited in this blueprint, so we can open them right away</summary>
		public TStructArray<FEditedDocumentInfo> LastEditedDocuments
		{
			get{ CheckIsValid();return new TStructArray<FEditedDocumentInfo>((FScriptArray)Marshal.PtrToStructure(_this.Get()+LastEditedDocuments__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+LastEditedDocuments__Offset, false);}
			
		}
		
		static readonly int Breakpoints__Offset;
		/// <summary>Persistent debugging options</summary>
		public TObjectArray<UBreakpoint>  Breakpoints
		{
					get{ CheckIsValid();return new TObjectArray<UBreakpoint>((FScriptArray)Marshal.PtrToStructure(_this.Get()+Breakpoints__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+Breakpoints__Offset, false);}
			
		}
		
		static readonly int WatchedPins__Offset;
		public TStructArray<FEdGraphPinReference> WatchedPins
		{
			get{ CheckIsValid();return new TStructArray<FEdGraphPinReference>((FScriptArray)Marshal.PtrToStructure(_this.Get()+WatchedPins__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+WatchedPins__Offset, false);}
			
		}
		
		static readonly int DeprecatedPinWatches__Offset;
		public TObjectArray<UEdGraphPin_Deprecated>  DeprecatedPinWatches
		{
					get{ CheckIsValid();return new TObjectArray<UEdGraphPin_Deprecated>((FScriptArray)Marshal.PtrToStructure(_this.Get()+DeprecatedPinWatches__Offset, typeof(FScriptArray)));}
					set{ CheckIsValid();Marshal.StructureToPtr(value.InterArray, _this.Get()+DeprecatedPinWatches__Offset, false);}
			
		}
		
		static readonly int ThumbnailInfo__Offset;
		/// <summary>Information for thumbnail rendering</summary>
		public UThumbnailInfo ThumbnailInfo
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + ThumbnailInfo__Offset); if (v == IntPtr.Zero)return null; UThumbnailInfo retValue = new UThumbnailInfo(); retValue._this = v; return retValue; }
			set{ CheckIsValid(); if (value == null)Marshal.WriteIntPtr(_this.Get() + ThumbnailInfo__Offset, IntPtr.Zero);else Marshal.WriteIntPtr(_this.Get() + ThumbnailInfo__Offset, value._this.Get()); }
			
		}
		
		static readonly int bBeingCompiled__Offset;
		/// <summary>The blueprint is currently compiled</summary>
		public bool bBeingCompiled
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bBeingCompiled__Offset, 1, 0, 1, 1);}
			
		}
		
		static readonly int CrcLastCompiledCDO__Offset;
		/// <summary>CRC for CDO calculated right after the latest compilation used by Reinstancer to check if default values were changed</summary>
		public uint CrcLastCompiledCDO
		{
			get{ CheckIsValid();return (uint)Marshal.PtrToStructure(_this.Get()+CrcLastCompiledCDO__Offset, typeof(uint));}
			
		}
		
		static readonly int CrcLastCompiledSignature__Offset;
		public uint CrcLastCompiledSignature
		{
			get{ CheckIsValid();return (uint)Marshal.PtrToStructure(_this.Get()+CrcLastCompiledSignature__Offset, typeof(uint));}
			
		}
		
		static readonly int OriginalClass__Offset;
		/// <summary>If this BP is just a duplicate created for a specific compilation, the reference to original GeneratedClass is needed</summary>
		public UClass OriginalClass
		{
			get{ CheckIsValid(); IntPtr v = Marshal.ReadIntPtr(_this.Get() + OriginalClass__Offset); return v; }
			
		}
		
		static readonly int bNativize__Offset;
		/// <summary>Deprecated properties.</summary>
		public bool bNativize
		{
			get{ CheckIsValid();return BoolWrap.Get(_this.Get(), bNativize__Offset, 1, 0, 1, 255);}
			
		}
		
		static UBlueprint()
		{
			IntPtr NativeClassPtr=GetNativeClassFromName("Blueprint");
			bRecompileOnLoad__Offset=GetPropertyOffset(NativeClassPtr,"bRecompileOnLoad");
			ParentClass__Offset=GetPropertyOffset(NativeClassPtr,"ParentClass");
			PRIVATE_InnermostPreviousCDO__Offset=GetPropertyOffset(NativeClassPtr,"PRIVATE_InnermostPreviousCDO");
			bHasBeenRegenerated__Offset=GetPropertyOffset(NativeClassPtr,"bHasBeenRegenerated");
			bIsRegeneratingOnLoad__Offset=GetPropertyOffset(NativeClassPtr,"bIsRegeneratingOnLoad");
			bIsNewlyCreated__Offset=GetPropertyOffset(NativeClassPtr,"bIsNewlyCreated");
			bForceFullEditor__Offset=GetPropertyOffset(NativeClassPtr,"bForceFullEditor");
			bRunConstructionScriptOnDrag__Offset=GetPropertyOffset(NativeClassPtr,"bRunConstructionScriptOnDrag");
			bGenerateConstClass__Offset=GetPropertyOffset(NativeClassPtr,"bGenerateConstClass");
			bGenerateAbstractClass__Offset=GetPropertyOffset(NativeClassPtr,"bGenerateAbstractClass");
			BlueprintDescription__Offset=GetPropertyOffset(NativeClassPtr,"BlueprintDescription");
			BlueprintCategory__Offset=GetPropertyOffset(NativeClassPtr,"BlueprintCategory");
			HideCategories__Offset=GetPropertyOffset(NativeClassPtr,"HideCategories");
			bDisplayCompilePIEWarning__Offset=GetPropertyOffset(NativeClassPtr,"bDisplayCompilePIEWarning");
			SearchGuid__Offset=GetPropertyOffset(NativeClassPtr,"SearchGuid");
			bDeprecate__Offset=GetPropertyOffset(NativeClassPtr,"bDeprecate");
			SimpleConstructionScript__Offset=GetPropertyOffset(NativeClassPtr,"SimpleConstructionScript");
			UbergraphPages__Offset=GetPropertyOffset(NativeClassPtr,"UbergraphPages");
			FunctionGraphs__Offset=GetPropertyOffset(NativeClassPtr,"FunctionGraphs");
			DelegateSignatureGraphs__Offset=GetPropertyOffset(NativeClassPtr,"DelegateSignatureGraphs");
			MacroGraphs__Offset=GetPropertyOffset(NativeClassPtr,"MacroGraphs");
			IntermediateGeneratedGraphs__Offset=GetPropertyOffset(NativeClassPtr,"IntermediateGeneratedGraphs");
			EventGraphs__Offset=GetPropertyOffset(NativeClassPtr,"EventGraphs");
			bDuplicatingReadOnly__Offset=GetPropertyOffset(NativeClassPtr,"bDuplicatingReadOnly");
			ComponentTemplates__Offset=GetPropertyOffset(NativeClassPtr,"ComponentTemplates");
			Timelines__Offset=GetPropertyOffset(NativeClassPtr,"Timelines");
			InheritableComponentHandler__Offset=GetPropertyOffset(NativeClassPtr,"InheritableComponentHandler");
			BlueprintType__Offset=GetPropertyOffset(NativeClassPtr,"BlueprintType");
			Status__Offset=GetPropertyOffset(NativeClassPtr,"Status");
			NewVariables__Offset=GetPropertyOffset(NativeClassPtr,"NewVariables");
			CategorySorting__Offset=GetPropertyOffset(NativeClassPtr,"CategorySorting");
			ImplementedInterfaces__Offset=GetPropertyOffset(NativeClassPtr,"ImplementedInterfaces");
			BlueprintSystemVersion__Offset=GetPropertyOffset(NativeClassPtr,"BlueprintSystemVersion");
			LastEditedDocuments__Offset=GetPropertyOffset(NativeClassPtr,"LastEditedDocuments");
			Breakpoints__Offset=GetPropertyOffset(NativeClassPtr,"Breakpoints");
			WatchedPins__Offset=GetPropertyOffset(NativeClassPtr,"WatchedPins");
			DeprecatedPinWatches__Offset=GetPropertyOffset(NativeClassPtr,"DeprecatedPinWatches");
			ThumbnailInfo__Offset=GetPropertyOffset(NativeClassPtr,"ThumbnailInfo");
			bBeingCompiled__Offset=GetPropertyOffset(NativeClassPtr,"bBeingCompiled");
			CrcLastCompiledCDO__Offset=GetPropertyOffset(NativeClassPtr,"CrcLastCompiledCDO");
			CrcLastCompiledSignature__Offset=GetPropertyOffset(NativeClassPtr,"CrcLastCompiledSignature");
			OriginalClass__Offset=GetPropertyOffset(NativeClassPtr,"OriginalClass");
			bNativize__Offset=GetPropertyOffset(NativeClassPtr,"bNativize");
			
		}
		
	}
	
}
#endif
#endif
