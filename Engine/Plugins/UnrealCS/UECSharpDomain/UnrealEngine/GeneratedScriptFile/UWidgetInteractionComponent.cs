//GENERATED: 
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace UnrealEngine{
public partial class UWidgetInteractionComponent:USceneComponent 
{
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern void SetCustomHitResult(IntPtr _this,ref FHitResult HitResult);
	
	/// <summary>Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom.</summary>
	public  void SetCustomHitResult(FHitResult HitResult)
	{
		CheckIsValid();
		SetCustomHitResult(_this.Get(),ref HitResult);
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern FVector2D Get2DHitLocation(IntPtr _this);
	
	/// <summary>Gets the last hit location on the widget in 2D, local pixel units of the render target.</summary>
	public  FVector2D Get2DHitLocation()
	{
		CheckIsValid();
		FVector2D ___ret = Get2DHitLocation(_this.Get());
		return ___ret;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern FHitResult GetLastHitResult(IntPtr _this);
	
	/// <summary>Gets the last hit result generated by the component.  Returns the custom hit result if that was set.</summary>
	public  FHitResult GetLastHitResult()
	{
		CheckIsValid();
		FHitResult ___ret = GetLastHitResult(_this.Get());
		return ___ret;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int IsOverHitTestVisibleWidget(IntPtr _this);
	
	/// <summary>
	/// Returns true if a widget under the hit result is has a visibility that makes it hit test
	/// visible.  e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible().
	/// </summary>
	public  bool IsOverHitTestVisibleWidget()
	{
		CheckIsValid();
		int ___ret = IsOverHitTestVisibleWidget(_this.Get());
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int IsOverFocusableWidget(IntPtr _this);
	
	/// <summary>
	/// Returns true if a widget under the hit result is focusable.  e.g. Slate widgets that
	/// return true for SupportsKeyboardFocus().
	/// </summary>
	public  bool IsOverFocusableWidget()
	{
		CheckIsValid();
		int ___ret = IsOverFocusableWidget(_this.Get());
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int IsOverInteractableWidget(IntPtr _this);
	
	/// <summary>
	/// Returns true if a widget under the hit result is interactive.  e.g. Slate widgets
	/// that return true for IsInteractable().
	/// </summary>
	public  bool IsOverInteractableWidget()
	{
		CheckIsValid();
		int ___ret = IsOverInteractableWidget(_this.Get());
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern IntPtr GetHoveredWidgetComponent(IntPtr _this);
	
	/// <summary>Get the currently hovered widget component.</summary>
	public  UWidgetComponent GetHoveredWidgetComponent()
	{
		CheckIsValid();
		IntPtr ___ret = GetHoveredWidgetComponent(_this.Get());
		if(___ret==IntPtr.Zero) return null; UWidgetComponent ___ret2= new UWidgetComponent(){ _this = ___ret }; return ___ret2;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern void ScrollWheel(IntPtr _this,float ScrollDelta);
	
	/// <summary>Sends a scroll wheel event to the widget under the last hit result.</summary>
	public  void ScrollWheel(float ScrollDelta)
	{
		CheckIsValid();
		ScrollWheel(_this.Get(),ScrollDelta);
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int SendKeyChar(IntPtr _this,string Characters,int bRepeat);
	
	/// <summary>
	/// Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in
	/// the string.
	/// </summary>
	public  bool SendKeyChar(string Characters,bool bRepeat=false)
	{
		CheckIsValid();
		int ___ret = SendKeyChar(_this.Get(),Characters,bRepeat?1:0);
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int PressAndReleaseKey(IntPtr _this,ref FKey Key);
	
	/// <summary>Does both the press and release of a simulated keyboard key.</summary>
	public  bool PressAndReleaseKey(FKey Key)
	{
		CheckIsValid();
		int ___ret = PressAndReleaseKey(_this.Get(),ref Key);
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int ReleaseKey(IntPtr _this,ref FKey Key);
	
	/// <summary>Releases a key as if it had been released by the keyboard.</summary>
	public  bool ReleaseKey(FKey Key)
	{
		CheckIsValid();
		int ___ret = ReleaseKey(_this.Get(),ref Key);
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern int PressKey(IntPtr _this,ref FKey Key,int bRepeat);
	
	/// <summary>
	/// Press a key as if it had come from the keyboard.  Avoid using this for 'a-z|A-Z', things like
	/// the Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being
	/// send to the widget.  So for those cases you should use SendKeyChar.
	/// </summary>
	public  bool PressKey(FKey Key,bool bRepeat=false)
	{
		CheckIsValid();
		int ___ret = PressKey(_this.Get(),ref Key,bRepeat?1:0);
		return ___ret!=0;
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern void ReleasePointerKey(IntPtr _this,ref FKey Key);
	
	/// <summary>
	/// Releases a key as if the mouse/pointer were the source of it.  Normally you would just use
	/// Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
	/// send other keys to signal widgets to take special actions if they're under the cursor.
	/// </summary>
	public  void ReleasePointerKey(FKey Key)
	{
		CheckIsValid();
		ReleasePointerKey(_this.Get(),ref Key);
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	static extern void PressPointerKey(IntPtr _this,ref FKey Key);
	
	/// <summary>
	/// Presses a key as if the mouse/pointer were the source of it.  Normally you would just use
	/// Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
	/// send other keys to signal widgets to take special actions if they're under the cursor.
	/// </summary>
	public  void PressPointerKey(FKey Key)
	{
		CheckIsValid();
		PressPointerKey(_this.Get(),ref Key);
		
	}
	
	[MethodImplAttribute(MethodImplOptions.InternalCall)]
	public static extern new IntPtr StaticClass();
}
}
